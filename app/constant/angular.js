export const angularinterview = [
    {
        question: "What is Angular Framework?",
        answer: "Angular is a TypeScript-based open-source front-end web application framework developed by Google. It is used to build dynamic single-page applications (SPAs) with features like dependency injection, two-way data binding, and modular architecture."
    },
    {
        question: "What is TypeScript?",
        answer: "TypeScript is a superset of JavaScript developed by Microsoft. It extends JavaScript by adding static types to improve developer productivity and maintainability. TypeScript compiles down to JavaScript, allowing it to run on any platform that supports JavaScript."
    },
    {
        question: "Write a pictorial diagram of Angular architecture.",
        answer: "Angular architecture consists of modules, components, templates, directives, services (with Dependency Injection), and routing. The architecture ensures efficient user input handling, data services, and view updates. (Diagram not included in the object but can be visualized.)"
    },
    {
        question: "What are the key components of Angular?",
        answer: "The key components of Angular are Modules, Components, Templates, Directives, Services (with Dependency Injection), and Routing."
    },
    {
        question: "What are directives?",
        answer: "Directives are classes in Angular that enhance the functionality of DOM elements. Types include Structural Directives (e.g., *ngIf, *ngFor), Attribute Directives (e.g., ngClass, ngStyle), and Custom Directives."
    },
    {
        question: "What are components?",
        answer: "Components are the building blocks of Angular applications, consisting of a template (HTML), class (TypeScript logic), styles (CSS), and a selector (custom HTML tag)."
    },
    {
        question: "What is a template?",
        answer: "A template is an HTML structure in Angular, enhanced with Angular directives, bindings, and expressions. It represents the view for a component and interacts with the component class."
    },
    {
        question: "What is a module?",
        answer: "A module is a logical container in Angular that organizes components, directives, pipes, and services. It is defined using the @NgModule decorator, with the root module being AppModule."
    },
    {
        question: "What are lifecycle hooks available?",
        answer: "Angular lifecycle hooks allow components to tap into specific stages of their creation and destruction. Examples include ngOnInit, ngOnChanges, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, and ngOnDestroy."
    },
    {
        question: "What is data binding?",
        answer: "Data binding connects the component's data to the template. Types include Interpolation ({{expression}}), Property Binding ([property]=\"value\"), Event Binding ((event)=\"handler\"), and Two-way Binding ([(ngModel)]=\"property\")."
    },
    {
        question: "What is metadata?",
        answer: "Metadata provides additional information about a class or component to Angular, defined using decorators like @Component and @NgModule."
    },
    {
        question: "What is Angular CLI?",
        answer: "Angular CLI (Command Line Interface) is a tool to initialize, develop, scaffold, and maintain Angular projects. It simplifies tasks like creating components, services, routing modules, and building production-ready apps."
    },
    {
        question: "What is Angular Framework?",
        answer: "Angular is a TypeScript-based open-source front-end web application framework developed by Google. It is used to build dynamic single-page applications (SPAs) with features like dependency injection, two-way data binding, and modular architecture."
    },
    {
        question: "What is TypeScript?",
        answer: "TypeScript is a superset of JavaScript developed by Microsoft. It extends JavaScript by adding static types to improve developer productivity and maintainability. TypeScript compiles down to JavaScript, allowing it to run on any platform that supports JavaScript."
    },
    {
        question: "Write a pictorial diagram of Angular architecture.",
        answer: "Angular architecture consists of modules, components, templates, directives, services (with Dependency Injection), and routing. The architecture ensures efficient user input handling, data services, and view updates. (Diagram not included in the object but can be visualized.)"
    },
    {
        question: "What are the key components of Angular?",
        answer: "The key components of Angular are Modules, Components, Templates, Directives, Services (with Dependency Injection), and Routing."
    },
    {
        question: "What are directives?",
        answer: "Directives are classes in Angular that enhance the functionality of DOM elements. Types include Structural Directives (e.g., *ngIf, *ngFor), Attribute Directives (e.g., ngClass, ngStyle), and Custom Directives."
    },
    {
        question: "What are components?",
        answer: "Components are the building blocks of Angular applications, consisting of a template (HTML), class (TypeScript logic), styles (CSS), and a selector (custom HTML tag)."
    },
    {
        question: "What is a template?",
        answer: "A template is an HTML structure in Angular, enhanced with Angular directives, bindings, and expressions. It represents the view for a component and interacts with the component class."
    },
    {
        question: "What is a module?",
        answer: "A module is a logical container in Angular that organizes components, directives, pipes, and services. It is defined using the @NgModule decorator, with the root module being AppModule."
    },
    {
        question: "What are lifecycle hooks available?",
        answer: "Angular lifecycle hooks allow components to tap into specific stages of their creation and destruction. Examples include ngOnInit, ngOnChanges, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, and ngOnDestroy."
    },
    {
        question: "What is data binding?",
        answer: "Data binding connects the component's data to the template. Types include Interpolation ({{expression}}), Property Binding ([property]=\"value\"), Event Binding ((event)=\"handler\"), and Two-way Binding ([(ngModel)]=\"property\")."
    },
    {
        question: "What is metadata?",
        answer: "Metadata provides additional information about a class or component to Angular, defined using decorators like @Component and @NgModule."
    },
    {
        question: "What is Angular CLI?",
        answer: "Angular CLI (Command Line Interface) is a tool to initialize, develop, scaffold, and maintain Angular projects. It simplifies tasks like creating components, services, routing modules, and building production-ready apps."
    },
    {
        question: "What is the difference between constructor and ngOnInit?",
        answer: "The constructor is a TypeScript feature used for initializing class members, whereas ngOnInit is a lifecycle hook specifically designed for Angular components to handle initialization logic once the component is created."
    },
    {
        question: "What is a service?",
        answer: "A service is a class in Angular used to encapsulate business logic, data, or reusable functionalities. Services are typically injected into components or other services using Dependency Injection."
    },
    {
        question: "What is dependency injection in Angular?",
        answer: "Dependency Injection (DI) is a design pattern used in Angular to provide objects (dependencies) to a class through the constructor. It ensures decoupling and reusability of components and services."
    },
    {
        question: "What is the purpose of async pipe?",
        answer: "The async pipe automatically subscribes to an observable or promise and updates the template whenever the value changes, simplifying reactive programming."
    },
    {
        question: "What is the purpose of *ngFor directive?",
        answer: "The *ngFor directive is used to loop through arrays and display a list of elements dynamically in the template."
    },
    {
        question: "What are pipes?",
        answer: "Pipes in Angular are used to transform data within templates. For example, they can format dates, numbers, or strings."
    },
    {
        question: "What is a parameterized pipe?",
        answer: "A parameterized pipe allows passing arguments to modify the output. For example, `{{ value | date:'shortDate' }}` formats a date with a specific pattern."
    },
    {
        question: "How do you chain pipes?",
        answer: "Pipes can be chained by using multiple pipe operators (|). For example: `{{ value | currency | uppercase }}`."
    },
    {
        question: "What is a custom pipe?",
        answer: "A custom pipe is a user-defined pipe that allows developers to create their own transformation logic for specific requirements."
    },
    {
        question: "What is the difference between pure and impure pipe?",
        answer: "Pure pipes process data without modifying the original input and are executed only when their input changes, while impure pipes run on every change detection cycle."
    },
    {
        question: "What is HttpClient and its benefits?",
        answer: "HttpClient is a service in Angular that allows communication with backend APIs via HTTP. Benefits include simplified HTTP requests, built-in observables, and automatic JSON conversion."
    },
    {
        question: "What are dynamic components?",
        answer: "Dynamic components are components that are created and inserted into the DOM at runtime rather than being declared in a template."
    },
    {
        question: "What are router events?",
        answer: "Router events are a series of events triggered during the routing process in Angular, such as navigation start, end, and error."
    },
    {
        question: "What is activated route?",
        answer: "ActivatedRoute is a service in Angular that provides access to route parameters, data, and query parameters associated with the current route."
    },
    {
        question: "How do you define routes?",
        answer: "Routes are defined using the RouterModule and an array of route objects, each specifying a path and the component to load. Example: `{ path: 'home', component: HomeComponent }`."
    },
    {
        question: "What is the purpose of Wildcard route?",
        answer: "A Wildcard route is used to handle undefined paths and typically redirects users to a 'Not Found' or similar page."
    },
    {
        question: "What is Angular Universal?",
        answer: "Angular Universal is a framework for server-side rendering (SSR) of Angular applications, improving SEO and initial load performance."
    },
    {
        question: "What is ng-content?",
        answer: "ng-content is a directive that enables content projection, allowing you to insert dynamic content into a component's template."
    },
    {
        question: "What is Angular Input and Output and EventEmitter?",
        answer: "Input and Output are decorators in Angular used for parent-child communication. EventEmitter is used with the Output decorator to emit events from the child to the parent."
    },
    {
        question: "What is Template Reference Variable in Angular?",
        answer: "A Template Reference Variable is a variable declared in a template using the # symbol. It provides access to a DOM element or Angular component instance."
    },
    {
        question: "What is ng-container in Angular?",
        answer: "ng-container is an Angular element that acts as a logical container without rendering any additional DOM."
    },
    {
        question: "How to use ng-template and TemplateRef in Angular?",
        answer: "ng-template is a directive for defining a reusable template. TemplateRef represents the template and can be used for dynamic rendering."
    },
    {
        question: "How to Use ngTemplateOutlet in Angular?",
        answer: "The ngTemplateOutlet directive is used to dynamically insert a template into a view using the [ngTemplateOutlet] binding."
    },
    {
        question: "What are Signals?",
        answer: "Signals in Angular represent reactive state management, providing a way to track and react to changes in data."
    },
    {
        question: "Why Signal?",
        answer: "Signals improve reactivity and state tracking in Angular applications, offering better integration with change detection."
    },
    {
        question: "Angular Signals and Observables: How and When to Use Each?",
        answer: "Signals are ideal for local state management, while Observables are better for asynchronous operations like API calls or streams."
    },
    {
        question: "What is Effect in Signal?",
        answer: "Effect in Signal is a mechanism to react to changes in Signals. Effects listen to signal changes and trigger side-effects, like updating the DOM or performing API calls, without altering the Signal's state."
    },
    {
        question: "What is ElementRef in Angular?",
        answer: "ElementRef is a wrapper around a native DOM element in Angular. It is used to directly interact with the DOM element, but its usage is discouraged for security reasons in favor of Renderer2."
    },
    {
        question: "What is Renderer2?",
        answer: "Renderer2 is a service in Angular that provides an API for safely manipulating the DOM, such as creating elements, adding classes, and handling events."
    },
    {
        question: "How to Use @ViewChild and @ViewChildren?",
        answer: "@ViewChild is used to get a reference to a single DOM element or directive in a component's template. @ViewChildren is used to get references to multiple elements or directives."
    },
    {
        question: "What are ContentChild and ContentChildren in Angular?",
        answer: "ContentChild and ContentChildren are decorators used to access projected content inside a component using queries. ContentChild gets a single element, while ContentChildren retrieves multiple elements."
    },
    {
        question: "What are decorators in Angular?",
        answer: "Decorators in Angular are functions that add metadata to classes, methods, properties, or parameters. Examples include @Component, @NgModule, @Injectable, and @Directive."
    },
    {
        question: "What are AfterViewInit, AfterViewChecked, AfterContentInit, and AfterContentChecked in Angular?",
        answer: "These are lifecycle hooks in Angular: AfterViewInit is triggered after the view is initialized, AfterViewChecked is triggered after the view is checked for changes, AfterContentInit is triggered after projected content is initialized, and AfterContentChecked is triggered after the content is checked for changes."
    },
    {
        question: "What is View Encapsulation in Angular?",
        answer: "View Encapsulation determines how styles in a component are scoped. Angular supports three options: Emulated (default, scoped styles using attributes), None (global styles), and ShadowDom (uses native Shadow DOM for isolation)."
    },
    {
        question: "What are Host and hostContext in Angular?",
        answer: "The 'Host' selector applies styles to the host element of a component, while 'hostContext' applies styles based on a parent class or context."
    },
    {
        question: "How does Angular Change Detection really work?",
        answer: "Angular's change detection checks for changes in data-bound properties and updates the DOM accordingly. It uses a tree of views and runs in the Angular Zone to capture asynchronous operations."
    },
    {
        question: "What is the relationship between Change Detection, Zone.js, Zoneless mode, Local Change Detection, and Signals?",
        answer: "Zone.js provides automatic tracking of asynchronous operations for change detection. Zoneless mode skips Zone.js, requiring manual triggering of change detection. Signals offer reactive state management, complementing or replacing traditional change detection."
    },
    {
        question: "What is Angular Signals Component API input, output, and model?",
        answer: "Angular's Signals Component API allows managing component inputs, outputs, and models reactively. Inputs and outputs are handled as Signals, enabling more efficient change detection and communication."
    },
    {
        question: "What is Resource API?",
        answer: "The Resource API in Angular provides a structured way to interact with RESTful APIs, managing CRUD operations and handling HTTP requests and responses."
    },
    {
        question: "What is an Angular Service?",
        answer: "An Angular Service is a singleton class used to share data, logic, or functionalities across different components of an Angular application. It is typically used to encapsulate business logic or reusable code."
    },
    {
        question: "What are Angular Services used for?",
        answer: "Angular Services are used for tasks such as fetching data from APIs, sharing data between components, encapsulating business logic, managing state, and implementing reusable functionalities."
    },
    {
        question: "What are the advantages of Angular Service?",
        answer: "Advantages include: (1) Code reusability by encapsulating logic in a single place, (2) Easy sharing of data across components, (3) Separation of concerns, (4) Improved testability, and (5) Simplified dependency injection."
    },
    {
        question: "What are the benefits of Dependency Injection?",
        answer: "Dependency Injection provides (1) Decoupled code for better modularity, (2) Enhanced testability by mocking dependencies, (3) Improved maintainability by centralizing dependency creation, and (4) Cleaner code by managing object lifetimes and resolving dependencies automatically."
    },
    {
        question: "What are the five main players in the Angular Dependency Injection Framework?",
        answer: "The five main players are: (1) Service: The class containing shared logic, (2) Component: The consumer of the service, (3) Injector: The system that provides the service instance, (4) Provider: The configuration specifying how to create or locate a dependency, and (5) Dependency: The required instance or class being injected."
    },
    {
        question: "What is Service Scope in Angular?",
        answer: "Service scope refers to the lifecycle and availability of a service. A service can be scoped to: (1) Application-wide using the `providedIn: 'root'` metadata, (2) Feature modules by adding it to a module's providers array, or (3) Component-specific by declaring it in a component's providers array."
    },
    {
        question: "What is Angular Injector?",
        answer: "The Angular Injector is a service responsible for instantiating and providing dependencies to classes like components and services. It resolves dependencies declared in constructors and ensures proper service instantiation."
    },
    {
        question: "When is Angular Injector created?",
        answer: "The Angular Injector is created during the application's initialization process, specifically when the Angular runtime compiles and bootstraps the root module."
    },
    {
        question: "How do you register a service with an injector?",
        answer: "A service is registered with an injector using providers. This can be done in multiple ways: (1) Using `providedIn` metadata in the service's @Injectable decorator, (2) Adding the service to a module's `providers` array, or (3) Adding the service to a component's `providers` array for component-level injection."
    },
    {
        question: "What are Angular Providers?",
        answer: "Angular Providers are objects used to configure the DI system. They specify how to create or retrieve a dependency. Common types include: (1) Class Providers (default), (2) Value Providers, (3) Factory Providers, and (4) Aliased Providers."
    },
    {
        question: "What are the types of Providers in Angular?",
        answer: "The main types of providers in Angular are: (1) **Class Providers**: The default type using a class as the provider, (2) **Value Providers**: Provides a fixed value, (3) **Factory Providers**: Uses a factory function to create a dependency, (4) **Existing Providers**: Alias another provider, and (5) **Multi Providers**: Allows multiple values for a single token."
    },
    {
        question: "How does Dependency Injection and Resolution work in Angular?",
        answer: "In Angular, Dependency Injection (DI) resolves dependencies by: (1) An injector checking for the dependency in its own scope, (2) If not found, the injector traverses up the injector hierarchy, (3) If the dependency is not found in any injector, an error is thrown. Angular uses a tree of injectors, with the root injector at the application level and child injectors at module, component, or directive levels."
    },
    {
        question: "What is the Element Injector Tree in Angular?",
        answer: "The Element Injector Tree is a hierarchy of injectors attached to Angular's component and directive tree. Each component has its own injector, which allows for scoped resolution of dependencies. The tree structure ensures that child injectors can override dependencies provided by parent injectors."
    },
    {
        question: "What does `providedIn` root, any, and platform mean in Angular?",
        answer: "The `providedIn` metadata determines where a service is provided: (1) **root**: The service is provided at the root injector and shared across the application, (2) **any**: A new instance of the service is created for each module or lazy-loaded module, and (3) **platform**: The service is provided in a special platform-level injector, shared across multiple Angular applications."
    },
    {
        question: "What are @Self, @SkipSelf, and @Optional decorators in Angular?",
        answer: "These decorators modify how dependencies are resolved: (1) **@Self**: Forces Angular to look for the dependency only in the current injector, (2) **@SkipSelf**: Forces Angular to skip the current injector and look for the dependency in parent injectors, (3) **@Optional**: Allows the dependency to be null if it is not found in the injector hierarchy."
    },
    {
        question: "Explain RxJS Observable?",
        answer: "An RxJS Observable is a stream of data that can emit values over time. Observables are lazy, meaning they don't execute until subscribed to, and they support asynchronous operations like events, HTTP calls, or timer-based operations."
    },
    {
        question: "What are RxJS operators?",
        answer: "RxJS operators are pure functions used to manipulate or transform data streams emitted by Observables. Examples include map, filter, mergeMap, and catchError."
    },
    {
        question: "What is Observable.pipe() and how to use it?",
        answer: "The `pipe()` method is used to compose and chain multiple RxJS operators. For example: `observable.pipe(map(x => x * 2), filter(x => x > 10))` applies the operators sequentially to transform the data."
    },
    {
        question: "What is the difference between RxJS of and from?",
        answer: "`of` creates an Observable from a set of values, whereas `from` creates an Observable from an array, promise, or iterable. Example: `of(1, 2, 3)` vs. `from([1, 2, 3])`."
    },
    {
        question: "Explain RxJS map operator?",
        answer: "The `map` operator transforms each emitted value by applying a function to it. For example: `source.pipe(map(x => x * 2))` doubles each emitted value."
    },
    {
        question: "Explain RxJS switchMap operator?",
        answer: "`switchMap` maps each value to a new Observable and unsubscribes from the previous Observable when a new value is emitted. It is commonly used for canceling HTTP requests."
    },
    {
        question: "Explain RxJS mergeMap operator?",
        answer: "`mergeMap` maps each emitted value to a new Observable and subscribes to all inner Observables simultaneously. It is useful for parallel operations."
    },
    {
        question: "Explain RxJS concatMap operator?",
        answer: "`concatMap` maps each emitted value to a new Observable but subscribes to them sequentially, waiting for the previous Observable to complete before moving to the next."
    },
    {
        question: "Explain RxJS exhaustMap operator?",
        answer: "`exhaustMap` maps each value to a new Observable but ignores any subsequent values until the current inner Observable completes. It is useful for handling long-running tasks."
    },
    {
        question: "How will you handle errors on Observable using RxJS throwError?",
        answer: "`throwError` is used to create an Observable that emits an error. It can be used in conjunction with `catchError` to handle errors."
    },
    {
        question: "How will you handle errors on Observable using RxJS catchError?",
        answer: "`catchError` is an operator that intercepts errors and allows you to handle them or return a new Observable. For example: `source.pipe(catchError(error => of('Fallback value')))`."
    },
    {
        question: "Explain RxJS retry operator?",
        answer: "`retry` resubscribes to the source Observable in case of an error, retrying a specified number of times. Example: `source.pipe(retry(3))` retries the Observable three times on error."
    },
    {
        question: "Explain RxJS filter operator?",
        answer: "The `filter` operator allows you to emit only the values that satisfy a given predicate. Example: `source.pipe(filter(x => x > 5))` emits values greater than 5."
    },
    {
        question: "Explain RxJS tap operator?",
        answer: "`tap` allows you to perform side effects, such as logging or debugging, without altering the data stream. Example: `source.pipe(tap(value => console.log(value)))`."
    },
    {
        question: "Explain RxJS takeUntil operator?",
        answer: "`takeUntil` emits values from the source Observable until another Observable emits a value, at which point it completes. It is commonly used to manage subscriptions."
    },
    {
        question: "Explain RxJS debounceTime operator?",
        answer: "`debounceTime` delays the emitted values by a specified time. If a new value is emitted within the time frame, the timer resets. It is useful for handling user input events like search."
    },
    {
        question: "Explain RxJS combineLatestWith operator?",
        answer: "`combineLatestWith` combines the latest values from multiple Observables whenever one emits. Example: `obs1.pipe(combineLatestWith(obs2))` emits tuples of the latest values."
    },
    {
        question: "Explain RxJS fromEvent operator?",
        answer: "`fromEvent` creates an Observable from DOM events. Example: `fromEvent(document, 'click')` emits click events from the document."
    },
    {
        question: "What is the difference between Subject, BehaviorSubject, ReplaySubject, and AsyncSubject in RxJS?",
        answer: "Subjects emit values to multiple subscribers: (1) **Subject**: Emits only to subscribers at the time of emission, (2) **BehaviorSubject**: Emits the latest value to new subscribers, (3) **ReplaySubject**: Emits all previous values to new subscribers, (4) **AsyncSubject**: Emits the last value to subscribers only when the source Observable completes."
    },
    {
        question: "What are the best practices for managing Observable subscriptions in Angular and ensuring there are no memory leaks?",
        answer: "Best practices include: (1) Unsubscribe manually in `ngOnDestroy`, (2) Use `async` pipes for auto-unsubscription, (3) Use `takeUntil` with a destroy signal, and (4) Use RxJS operators like `shareReplay` to manage shared subscriptions."
    },
    {
        question: "What are the differences between cold Observable and hot Observable?",
        answer: "Cold Observables start emitting values only when subscribed to, while hot Observables emit values regardless of subscriptions. Example: HTTP requests are cold, and event streams are hot."
    },
    {
        question: "What are the differences between Observables and Promises?",
        answer: "Observables: (1) Lazy and can emit multiple values, (2) Can be canceled, (3) Support operators for transformations. Promises: (1) Eager and emit a single value, (2) Cannot be canceled, (3) No operator support."
    },
    {
        question: "What is a higher-order Observable?",
        answer: "A higher-order Observable is an Observable that emits other Observables. Operators like `mergeAll` or `switchAll` are used to flatten and subscribe to these inner Observables."
    },
    {
        question: "How can you share a single Observable among multiple subscribers?",
        answer: "You can share a single Observable using operators like `share`, `shareReplay`, or `publish`. These operators ensure that the Observable executes only once and shares the results with all subscribers."
    },
    {
        question: "Describe the types of forms created in Angular application?",
        answer: "In Angular, there are two types of forms: (1) **Reactive Forms**: These are programmatically managed, more scalable, and flexible, where form control is created and handled explicitly in the component. (2) **Template-driven Forms**: These are simpler to use, where form control is defined in the HTML template, and Angular automatically binds the controls to the component."
    },
    {
        question: "How will you create a reactive form in Angular?",
        answer: "To create a reactive form in Angular, you need to import `ReactiveFormsModule` from `@angular/forms` in your module. In the component, define a `FormGroup` and `FormControl` for each field, and use the `formGroup` directive in the template to bind it to the form."
    },
    {
        question: "Explain FormControl?",
        answer: "`FormControl` represents a single input element in a form and tracks its value and validation status. It is instantiated using `new FormControl(initialValue, validators)`. It can be used to track individual form controls like text inputs."
    },
    {
        question: "Explain FormGroup?",
        answer: "`FormGroup` is a collection of `FormControl` objects. It is used to group form controls together. It can be instantiated using `new FormGroup({ controlName: new FormControl() })`. `FormGroup` allows tracking the validity and status of multiple controls collectively."
    },
    {
        question: "Explain FormArray?",
        answer: "`FormArray` is used when you have an array of form controls. It is a collection of `FormControl` or `FormGroup` instances and can be dynamically manipulated (added, removed). It is instantiated using `new FormArray([controls])`."
    },
    {
        question: "Explain FormBuilder?",
        answer: "`FormBuilder` is a service that simplifies the creation of `FormGroup`, `FormControl`, and `FormArray` instances. It provides convenient methods like `group()`, `control()`, and `array()` for creating forms. It is typically used to streamline form creation in reactive forms."
    },
    {
        question: "Explain FormRecord?",
        answer: "`FormRecord` is a new type introduced in Angular 15 as a more flexible, strongly-typed alternative to `FormGroup`. It is an object that represents a group of form controls and their associated values, offering better type safety and structure."
    },
    {
        question: "How will you use valueChanges?",
        answer: "`valueChanges` is an Observable that emits the value of the form control whenever it changes. You can subscribe to it using `control.valueChanges.subscribe(value => { /* logic */ })` to react to changes in real time."
    },
    {
        question: "How will you use statusChanges?",
        answer: "`statusChanges` is an Observable that emits the status of a form control (valid, invalid, pending, or disabled) whenever it changes. You can subscribe to it using `control.statusChanges.subscribe(status => { /* logic */ })`."
    },
    {
        question: "What is the difference between setValue() and patchValue()?",
        answer: "`setValue()` requires all form controls to be updated and will throw an error if any control is missing. In contrast, `patchValue()` allows partial updates, only changing the specified controls in the form."
    },
    {
        question: "How will you add and remove controls on FormGroup dynamically?",
        answer: "To dynamically add or remove controls in a `FormGroup`, you can use the `addControl(name, control)` method to add a control, and `removeControl(name)` to remove a control."
    },
    {
        question: "What is the difference between (ngModelChange) and (change)?",
        answer: "`(ngModelChange)` is an Angular event that is emitted whenever the value of the bound model changes (used with `ngModel`). `(change)` is a native DOM event that is fired when an input field loses focus and its value has changed."
    },
    {
        question: "How to add async validation in FormControl?",
        answer: "To add async validation in `FormControl`, you can use the `asyncValidator` option when creating a `FormControl`. For example: `new FormControl('', [Validators.required], [this.asyncValidator()])` where `asyncValidator()` is a function returning an observable."
    },
    {
        question: "How will you validate template-driven form?",
        answer: "In template-driven forms, validation is performed using built-in directives like `required`, `minlength`, `maxlength`, etc., in the template. You can access the validation status using the `ngModel` directive (e.g., `#name='ngModel'`), and check the validity properties like `name.valid`."
    },
    {
        question: "Uses of Angular Route Guards",
        answer: "Angular Route Guards are used to control access to routes based on certain conditions. They are typically used to: (1) Prevent navigation to a route, (2) Protect routes requiring authentication, (3) Resolve data before navigating to a route, (4) Prevent navigation away from a route if unsaved changes exist, and (5) Lazy load routes based on certain conditions."
    },
    {
        question: "Types of Route Guards",
        answer: "There are five types of Route Guards in Angular: (1) **CanActivate**: Prevents or allows navigation to a route. (2) **CanActivateChild**: Prevents or allows navigation to child routes. (3) **CanDeactivate**: Prevents or allows navigation away from a route. (4) **Resolve**: Fetches data before a route is activated. (5) **CanLoad**: Prevents or allows lazy-loaded routes to be loaded."
    },
    {
        question: "What is CanActivate Guard?",
        answer: "The `CanActivate` guard is used to prevent or allow navigation to a route based on conditions like authentication or permissions. It is implemented as a service and used in the routing configuration to determine whether a route should be activated. For example: `canActivate: [AuthGuard]`."
    },
    {
        question: "What is CanActivateChild Guard?",
        answer: "The `CanActivateChild` guard is similar to `CanActivate`, but it specifically applies to child routes. It prevents or allows navigation to child routes of a parent route based on a condition. It can be used to apply the same restrictions across all child routes of a parent route."
    },
    {
        question: "What is CanDeactivate Guard?",
        answer: "The `CanDeactivate` guard is used to prevent or allow navigation away from the current route. This is typically used when the user has unsaved changes in a form or a component and tries to navigate away. The guard can ask for user confirmation before allowing navigation."
    },
    {
        question: "How to Use Resolve Guard?",
        answer: "The `Resolve` guard is used to fetch data before a route is activated. It ensures that all required data is fetched before the component is instantiated. It is defined in the routing configuration with a `resolve` property. For example: `resolve: { data: DataResolver }` where `DataResolver` fetches data before the route activates."
    },
    {
        question: "How to Use CanLoad Guard?",
        answer: "The `CanLoad` guard is used to prevent or allow lazy-loaded routes from being loaded. It is useful when you want to load a module only if certain conditions are met, like user authentication. It is applied to lazy-loaded routes in the routing configuration with `canLoad: [AuthGuard]`."
    },
    {
        question: "Why Handle Errors?",
        answer: "Handling errors is crucial in Angular applications to ensure a smooth user experience and prevent the app from crashing or behaving unpredictably. Proper error handling allows the application to react to failures (e.g., network issues, invalid responses) in a controlled way, providing feedback to the user and allowing the application to recover or retry the operation if necessary."
    },
    {
        question: "What is HttpErrorResponse?",
        answer: "`HttpErrorResponse` is an object that represents an error response from an HTTP request in Angular. It is part of the `@angular/common/http` module and contains details about the error, such as the status code, error message, and headers. This object is returned in case of an unsuccessful HTTP request, allowing developers to manage different error scenarios like 404 (Not Found), 500 (Server Error), and others."
    },
    {
        question: "How Can Catching Errors in HTTP Request?",
        answer: "In Angular, errors from HTTP requests can be caught using the `catchError` operator from RxJS. This operator can be used inside the `pipe()` method to handle errors and provide a fallback value or rethrow the error. For example: `httpClient.get(url).pipe(catchError(error => { return of('Error occurred') }))`. You can also catch errors globally using an HTTP interceptor."
    },
    {
        question: "What is Angular Http Interceptor?",
        answer: "An `HttpInterceptor` in Angular is a service that can intercept HTTP requests and responses before they are sent or received. It allows you to modify requests (e.g., adding authentication tokens) or responses (e.g., logging or handling errors). Interceptors are powerful for tasks like global error handling, setting HTTP headers, logging requests, and retrying failed requests. They are implemented by creating a service that implements `HttpInterceptor` interface and provided in the `HTTP_INTERCEPTORS` array."
    }
];

console.log(angularinterview);
